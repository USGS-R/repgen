#' Plot a time series on a third axis
#' @title printWithThirdYAxis
#' @param plot A gsplot, plot object.
#' @seealso \code{\link{log_tick_marks}}
printWithThirdYAxis <- function(plot) {
  axisDistance <- 4.5
  
  mar_vals <- par(plot)$mar
  if(is.null(mar_vals)){
    mar_vals <- par('mar')
  } 
  mar_vals[4] <- mar_vals[4] + axisDistance
  par(mar=mar_vals)
  
  print(plot)
  plot
  minor.ticks <- pretty(ylim(plot,6))
  major.ticks <- log_tick_marks(ylim(plot,6)[[1]], ylim(plot,6)[[2]])
  major.ticks <- major.ticks[major.ticks <= ylim(plot, 6)[[2]]]
  ticks <- major.ticks[major.ticks >= ylim(plot, 6)[[1]]]
  
  #Only add additional tick marks if we don't have many generated by the log ticks function
  if(length(ticks) <= 3)
  {
    ticks <- unique(append(major.ticks, minor.ticks))
  }
  
  #Only remove decimals from tick marks if the y range is great enough that they're not necessary
  #Add points below and above the plot to extaned the axis bar to the full plot height
  if((ylim(plot,6)[[2]]-ylim(plot,6)[[1]]) >= 10)
  {
    ticks <- trunc(append(ticks, c(-1, ylim(plot,6)[[2]]*2)))
  } else {
    ticks <- append(ticks, c(-1, ylim(plot,6)[[2]]*2))
  }
  
  axis(side=4, at=ticks, line=axisDistance, las=0)
  mtext(plot$side.6$label, side=4, line=axisDistance+1.5, padj=0)
}


#' Add tick marks to logarithmic axis
#' @title log_tick_marks
#' @param min ylim function returning minimum axis range
#' @param max ylim function returning maximum axis range
log_tick_marks <- function(min,max)
{
  nsplit <- abs(round(log10(max-min)))
  i <- 0
  nurange <- c()
  while(i<=nsplit) {
    nurange <- c(nurange,sapply(c(1,2,5),function(x) x*(10^i)))
    i <- i+1;
  }
  nurange
}

#' Add x-axis labels
#' @title XAxisLabels
#' @description Add x-axis labels to five year GW summary plots, and DV hydrographs
#' having time intervals of one year or more.
#' @param object A gsplot, plot object.
#' @param text Vector of month abbreviations.
#' @param at.months Vector of month dates to label month abbreviations (in
#'                  "text" vector) at.
#' @param at.years Vector of dates to label years at.
#' @return The passed-in gsplot object, with x-axis labeled.
XAxisLabels <- function(object, text, at.months, at.years) {
  return(
    mtext(
      object,
      text = text, at = at.months,
      cex = 0.5, side = 1
    ) %>%
      mtext(
        text = year(at.years), at = at.years,
        line = 1, side = 1
      )
  )
}

#' Delineate year boundaries
#' @title DelineateYearBoundaries
#' @description Delineate year boundaries on five year GW summary plots, and DV hydrographs
#' having time intervals of one year or more.
#' @param object A gsplot, plot object.
#' @param years A sequence of year begin dates to draw the lines at.
#' @return The passed-in gsplot object, with year boundaries delineated.
DelineateYearBoundaries <- function(object, years) {
  return(
    abline(
      object,
      v = years, col = "gray47",
      lwd = 2, where = 'first'
    )
  )
}

#' Add To gsplot
#' @param gsplot A gsplot, plot object.
#' @param plotConfig of gsplot calls to make
#' @return A modified gsplot, plot object, with everything in the plot config included.
AddToGsplot <- function(gsplot, plotConfig) {
  for (j in seq_len(length(plotConfig))) {
    gsplot <-
        do.call(names(plotConfig[j]), append(list(object = gsplot), plotConfig[[j]]))
  }
  
  error_bars <- grep('error_bar', names(plotConfig))
  for (err in error_bars) {
    gsplot <- extendYaxisLimits(gsplot, plotConfig[[err]])
  }
  
  return(gsplot)
}

#' Format time series for plotting
#'
#' @description Helper function that primes a time series for plotting
#' by extracing the points data frame from the list, adding the legend
#' name to that data frame, and removing zero/negative value rows if necessary
#' @param series The time series data to format for plotting
#' @param removeZeroNegativeFlag Whether or not to remove zero and negative values
formatTimeSeriesForPlotting <- function(series, removeZeroNegativeFlag=NULL){
  if(anyDataExist(series[['points']])){
    seriesLegend <- rep(series[['legend.name']], nrow(series[['points']]))
    series <- series[['points']]
    series[['legend.name']] <- seriesLegend
    
    if(!isEmptyOrBlank(removeZeroNegativeFlag) && removeZeroNegativeFlag){
      series <- removeZeroNegative(series)
    }
  }
  
  return(series)
}

formatTimeSeriesListForPlotting <- function(seriesList, excludeZeroNegativeFlag=NULL){
  if(!is.null(seriesList) && length(seriesList) > 0){
    dataFrameList <- lapply(seriesList, function(e){
      series <- e[['points']]

      if(!isEmptyOrBlank(excludeZeroNegativeFlag) && excludeZeroNegativeFlag){
        series <- removeZeroNegative(series)
      }

      if(nrow(series) == 0){
        return(NULL)
      }
      
      series[['legend.name']] <- e[['legend.name']]
      return(as.list(series))
    })

    dataFrameList <- dataFrameList[unname(unlist(lapply(dataFrameList, function(e) {return(!is.null(e))})))]
    return(dataFrameList)
  }

  return(NULL)
}

plotTimeSeries <- function(plot_object, ts, name, yLabel, timezone, excludeZeroNegativeFlag, isDV=FALSE){
  if(!is.null(ts) && anyDataExist(ts[['points']])){
    series <- splitDataGapsTimeSeries(ts, name, timezone, excludeZeroNegativeFlag, isDV=TRUE)
    series <- formatTimeSeriesListForPlotting(series, excludeZeroNegativeFlag)
    
    for(i in seq_len(length(series))){
      plot_object <- plotDVItem(plot_object, series[[i]], name, yLabel, isDV)
    }
  }
  
  return(plot_object)
}

plotItem <- function(plot_object, item, name, yLabel="", isDV=FALSE){
  if(!is.null(item) && anyDataExist(item)){
    legendName <- item['legend.name']
    plotItem <- getDVHydrographPlotConfig(item, name, yLabel)
    
    for(j in seq_len(length(plotItem))){
      if(isDV){
        plotItem[[j]] <- extendStep(plotItem[[j]])
      }
      
      plot_object <- do.call(names(plotItem[j]), append(list(object = plot_object), plotItem[[j]]))
    }
  }
  
  return(plot_object)
}