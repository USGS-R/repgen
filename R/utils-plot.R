#' Plot a time series on a third axis
#' @title printWithThirdYAxis
#' @param plot A gsplot, plot object.
#' @seealso \code{\link{log_tick_marks}}
printWithThirdYAxis <- function(plot) {
  axisDistance <- 4.5
  
  mar_vals <- par(plot)$mar
  if(is.null(mar_vals)){
    mar_vals <- par('mar')
  } 
  mar_vals[4] <- mar_vals[4] + axisDistance
  par(mar=mar_vals)
  
  print(plot)
  plot
  minor.ticks <- pretty(ylim(plot,6))
  major.ticks <- log_tick_marks(ylim(plot,6)[[1]], ylim(plot,6)[[2]])
  major.ticks <- major.ticks[major.ticks <= ylim(plot, 6)[[2]]]
  ticks <- major.ticks[major.ticks >= ylim(plot, 6)[[1]]]
  
  #Only add additional tick marks if we don't have many generated by the log ticks function
  if(length(ticks) <= 3)
  {
    ticks <- unique(append(major.ticks, minor.ticks))
  }
  
  #Only remove decimals from tick marks if the y range is great enough that they're not necessary
  #Add points below and above the plot to extaned the axis bar to the full plot height
  if((ylim(plot,6)[[2]]-ylim(plot,6)[[1]]) >= 10)
  {
    ticks <- trunc(append(ticks, c(-1, ylim(plot,6)[[2]]*2)))
  } else {
    ticks <- append(ticks, c(-1, ylim(plot,6)[[2]]*2))
  }
  
  axis(side=4, at=ticks, line=axisDistance, las=0)
  mtext(plot$side.6$label, side=4, line=axisDistance+1.5, padj=0)
}


#' Add tick marks to logarithmic axis
#' @title log_tick_marks
#' @param min ylim function returning minimum axis range
#' @param max ylim function returning maximum axis range
log_tick_marks <- function(min,max)
{
  nsplit <- abs(round(log10(max-min)))
  i <- 0
  nurange <- c()
  while(i<=nsplit) {
    nurange <- c(nurange,sapply(c(1,2,5),function(x) x*(10^i)))
    i <- i+1;
  }
  nurange
}

#' Add x-axis labels
#' @title XAxisLabels
#' @description Add x-axis labels to five year GW summary plots, and DV hydrographs
#' having time intervals of one year or more.
#' @param object A gsplot, plot object.
#' @param text Vector of month abbreviations.
#' @param at.months Vector of month dates to label month abbreviations (in
#'                  "text" vector) at.
#' @param at.years Vector of dates to label years at.
#' @return The passed-in gsplot object, with x-axis labeled.
XAxisLabels <- function(object, text, at.months, at.years) {
  return(
    mtext(
      object,
      text = text, at = at.months,
      cex = 0.5, side = 1
    ) %>%
      mtext(
        text = year(at.years), at = at.years,
        line = 1, side = 1
      )
  )
}

#' Delineate year boundaries
#' @title DelineateYearBoundaries
#' @description Delineate year boundaries on five year GW summary plots, and DV hydrographs
#' having time intervals of one year or more.
#' @param object A gsplot, plot object.
#' @param years A sequence of year begin dates to draw the lines at.
#' @return The passed-in gsplot object, with year boundaries delineated.
DelineateYearBoundaries <- function(object, years) {
  return(
    abline(
      object,
      v = years, col = "gray47",
      lwd = 2, where = 'first'
    )
  )
}

#' Add To gsplot
#' @param gsplot A gsplot, plot object.
#' @param plotConfig of gsplot calls to make
#' @return A modified gsplot, plot object, with everything in the plot config included.
AddToGsplot <- function(gsplot, plotConfig) {
  for (j in seq_len(length(plotConfig))) {
    gsplot <-
        do.call(names(plotConfig[j]), append(list(object = gsplot), plotConfig[[j]]))
  }
  
  error_bars <- grep('error_bar', names(plotConfig))
  for (err in error_bars) {
    gsplot <- extendYaxisLimits(gsplot, plotConfig[[err]])
  }
  
  return(gsplot)
}

#' TODO
extendYaxisLimits <- function(gsplot, error_bar_args){
  side <- ifelse(!is.null(error_bar_args[['side']]), error_bar_args[['side']], 2)
  side_nm <- paste0('side.', side)
  
  lowest_error_bar <- min(error_bar_args[['y']] - error_bar_args[['y.low']])
  lowest_y <- min(ylim(gsplot, side=side)[1], lowest_error_bar)
  
  highest_error_bar <- max(error_bar_args[['y']] + error_bar_args[['y.high']])
  highest_y <- max(ylim(gsplot, side=side)[2], highest_error_bar)
  
  gsplot[[side_nm]][['lim']] <- c(lowest_y, highest_y)
  return(gsplot)
}

#' Format time series for plotting
#'
#' @description Helper function that primes a time series for plotting
#' by extracing the points data frame from the list, adding the legend
#' name to that data frame, and removing zero/negative value rows if necessary
#' @param series The time series data to format for plotting
#' @param removeZeroNegativeFlag Whether or not to remove zero and negative values
#' @return A data frame representing the time series for plotting
formatTimeSeriesForPlotting <- function(series, removeZeroNegativeFlag=NULL){
  if(anyDataExist(series[['points']])){
    seriesLegend <- rep(series[['legend.name']], nrow(series[['points']]))
    series <- series[['points']]
    series[['legend.name']] <- seriesLegend
    
    if(!isEmptyOrBlank(removeZeroNegativeFlag) && removeZeroNegativeFlag){
      series <- removeZeroNegative(series)
    }
  }
  
  return(series)
}

#' Format time series list for plotting
#'
#' @description Helper function for formating a spearated list of time series
#' that are all part of the same overall time series. This is primarily used for
#' time series that have been split up because of gaps caused by estimated periods
#' or actual gaps in data.
#' @param seriesList The time series list to format for plotting
#' @param excludeZeroNegativeFlag Whether or not zero and negative values should be removed
#' @return A list of formated time series data frames
formatTimeSeriesListForPlotting <- function(seriesList, excludeZeroNegativeFlag=NULL){
  if(!is.null(seriesList) && length(seriesList) > 0){
    dataFrameList <- lapply(seriesList, function(e){
      series <- e[['points']]

      if(!isEmptyOrBlank(excludeZeroNegativeFlag) && excludeZeroNegativeFlag){
        series <- removeZeroNegative(series)
      }

      if(nrow(series) == 0){
        return(NULL)
      }
      
      series[['legend.name']] <- e[['legend.name']]
      return(as.list(series))
    })

    dataFrameList <- dataFrameList[unname(unlist(lapply(dataFrameList, function(e) {return(!is.null(e))})))]
    return(dataFrameList)
  }

  return(NULL)
}

#' Plot Time Series
#' 
#' @description Function that takes a gsplot object and the necessary time series data and
#' formats the time series properly for plotting and then plots it.
#' @param plot_object The gsplot object to plot onto
#' @param ts The Time Series to plot
#' @param name The variable name to use for the time series (used for style and config matching)
#' @param yLabel The label to put onto the Y-Axis for this time series
#' @param timezone The timezone of the time series (used for calculating gaps)
#' @param excludeZeroNegativeFlag Whether or not to remove zero and negative values from the ts
#' @param configFunction The function to use for fetching the style and config data for this TS
#' @param isDV Whether or not the plot is a daily value plot (default: FALSE)
plotTimeSeries <- function(plot_object, ts, name, yLabel, timezone, excludeZeroNegativeFlag, configFunction, isDV=FALSE){
  if(!is.null(ts) && anyDataExist(ts[['points']])){
    series <- splitDataGapsTimeSeries(ts, name, timezone, excludeZeroNegativeFlag, isDV=isDV)
    series <- formatTimeSeriesListForPlotting(series, excludeZeroNegativeFlag)
    
    for(i in seq_len(length(series))){
      plot_object <- plotItem(plot_object, series[[i]], name, configFunction, yLabel, isDV)
    }
  }
  
  return(plot_object)
}

#' Plot Item
#' 
#' @description Function that takes a gsplot object and the necessary item data and
#' then formats the item properly for plotting and plots it.
#' @param plot_object The gsplot object to plot onto
#' @param item The item to plot
#' @param name The variable name to use for the item (used for style and config matching)
#' @param configFunction The function to use for fetching the style and config data for this TS
#' @param yLabel The label to put onto the Y-Axis for this item (default: "")
#' @param isDV Whether or not the plot is a daily value plot (defulat: FALSE)
plotItem <- function(plot_object, item, name, configFunction, yLabel="", isDV=FALSE){
  if(!is.null(item) && anyDataExist(item)){
    legendName <- item['legend.name']
    plotItem <- configFunction(item, name, yLabel)
    
    for(j in seq_len(length(plotItem))){
      if(isDV){
        plotItem[[j]] <- extendStep(plotItem[[j]])
      }
      
      plot_object <- do.call(names(plotItem[j]), append(list(object = plot_object), plotItem[[j]]))
    }
  }
  
  return(plot_object)
}

#' Calculate Lims
#' For a data frame of points, will calculate a lims object. X and Y field names can be configured for the points.
#' @param pts data frame of points
#' @param xMinField name of the field which will contain the min x value (default "time")
#' @param xMaxField name of the field which will contain the max x value (default "value")
#' @param yMinField name of the field which will contain the min y value (default "time")
#' @param yMaxField name of the field which will contain the max y value (default "value")
calculateLims <- function(pts = NULL, xMinField = 'time', xMaxField = 'time', yMinField = 'value', yMaxField = 'value'){
  x_mx <- max(pts[[xMaxField]], na.rm = TRUE)
  x_mn <- min(pts[[xMinField]], na.rm = TRUE)
  y_mx <- max(pts[[yMaxField]], na.rm = TRUE)
  y_mn <- min(pts[[yMinField]], na.rm = TRUE)
  if (any(is.na(c(x_mx, x_mn, y_mx, y_mn)))){
    stop('missing or NA values in points. check input json.')
  }
  ylim = c(y_mn, y_mx)
  xlim = c(x_mn, x_mx)
  return(list(xlim = xlim, ylim = ylim))
}