#shared functions between reports

#' Create R Markdown and Run Rendering
#' 
#' @param data Input data to create a plot.
#' @param author The name of person generating the report.
#' @param reportName The name of report being generated (current options:
#'   "dvhydrograph", "fiveyruvhydrograph", "vdiagram").
#' @rdname startRender 
#' @export 
startRender <- function(data, author, reportName) {
  data <- data
  
  wd <- getwd()
  tmp_folder_name <- paste0('tmp-', reportName)
  
  output_dir <- paste0(wd, "/", tmp_folder_name)
  
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  #copy all shared files to tmp folder
  shared_files <- list.files(system.file('shared', package = 'repgen'), full.names = TRUE)
  file.copy(shared_files, output_dir)
  
  #copy all report inst files to tmp folder
  report_files <- list.files(system.file(reportName, package = 'repgen'), full.names = TRUE)
  file.copy(report_files, output_dir)
  
  if(reportName == "vdiagram"){
    rmd_file <- makeVDiagramRmd(output_dir, data, output_dir)
  } else {
    rmd_file <- system.file(reportName, paste0(reportName, '.Rmd'), package = 'repgen')
  }
  
  out_file <- render(rmd_file, paste0("html_document"), params = list(author=author), 
                     output_dir = output_dir, intermediates_dir = output_dir, 
                     output_options=c(paste0("lib_dir=", output_dir)), 
                     clean=TRUE)
  
  #try to clean up old temp files
  cleanTempSpace()
  
  return(out_file)
}

printWithThirdYAxis <- function(plot) {
  axisDistance <- 4.5

  mar_vals <- par(plot)$mar
  if(is.null(mar_vals)){
    mar_vals <- par('mar')
  } 
  mar_vals[4] <- mar_vals[4] + axisDistance
  par(mar=mar_vals)

  print(plot)
  plot
  minor.ticks <- pretty(ylim(plot,6))
  major.ticks <- log_tick_marks(ylim(plot,6)[[1]], ylim(plot,6)[[2]])
  major.ticks <- major.ticks[major.ticks <= ylim(plot, 6)[[2]]]
  ticks <- major.ticks[major.ticks >= ylim(plot, 6)[[1]]]
  
  #Only add additional tick marks if we don't have many generated by the log ticks function
  if(length(ticks) <= 3)
  {
    ticks <- unique(append(major.ticks, minor.ticks))
  }
  
  #Only remove decimals from tick marks if the y range is great enough that they're not necessary
  #Add points below and above the plot to extaned the axis bar to the full plot height
  if((ylim(plot,6)[[2]]-ylim(plot,6)[[1]]) >= 10)
  {
    ticks <- trunc(append(ticks, c(-1, ylim(plot,6)[[2]]*2)))
  } else {
    ticks <- append(ticks, c(-1, ylim(plot,6)[[2]]*2))
  }

  axis(side=4, at=ticks, line=axisDistance, las=0)
  mtext(plot$side.6$label, side=4, line=axisDistance+1.5, padj=0)
}

log_tick_marks <- function(min,max)
{
    nsplit <- abs(round(log10(max-min)))
    i <- 0
    nurange <- c()
    while(i<=nsplit) {
        nurange <- c(nurange,sapply(c(1,2,5),function(x) x*(10^i)))
        i <- i+1;
    }
    nurange
}

printReportFeature <- function(feature, isTable=FALSE, m=NULL, mar_values=c(8, 3, 4, 3)){
  if(!is.null(mar_values)){
    par(mar=mar_values)
  }

  if(!isEmpty(feature)){
    if(isTable){
      print(kable(feature))
      cat("\n\n")
    } else if(!is.null(m)){
      msg <- paste(feature, 'in', m)
      cat(msg)
    } else if(!is.null(feature$side.6)) {
      printWithThirdYAxis(feature)
      cat("\n\n")
    } else {
      print(feature)
      cat("\n\n")
    }
  } else {
    return()
  }
}

reorderPlot <- function(object, list, var_name, elementNames){
  for (i in seq_along(elementNames)){
    
    yes <- grep(elementNames[i], lapply(object[[list]], function(x) {x[[var_name]]}))
    no <- grep(elementNames[i], lapply(object[[list]], function(x) {x[[var_name]]}), invert=TRUE)
    
    #remove grids so they don't appear in the legend
    if (elementNames[i] %in% c("verticalGrids", "horizontalGrids")) { 
      if(list=="view.1.2") {
        for(y in yes){
          object[[list]][[y]][[var_name]] <- NULL
        }
        object[[list]] <- object[[list]][append(yes, no)]
      } else if(list=="legend"){object[[list]][yes] <- NULL}
    } else {
      object[[list]] <- object[[list]][append(yes, no)]
    }
    
  }
  
  class(object) <- "gsplot"
  return(object)
}

#' Determines whether a time series should be plotted relative to a log10
#' vertical axis.
#' 
#' @param all_data A set of time series data, as list of fields.
#' @param ts_data A single time series, as ordinal sequence of (time,value)
#'        pairs.
#' @param series The field name of the time series.
#' @export
isLogged <- function(all_data, ts_data, series) {

  isVolFlow <- all_data[[series]][['isVolumetricFlow']]
  zero_logic <- zeroValues(ts_data, "value")
  neg_logic <- negValues(ts_data, "value")
  ignoreZeroNegative <- getReportMetadata(all_data, 'excludeZeroNegative')
  loggingError <- (zero_logic || neg_logic) && 
    ( isEmptyOrBlank(ignoreZeroNegative) || !ignoreZeroNegative )
  
  if(is.null(isVolFlow) || !isVolFlow || loggingError){
    logAxis <- FALSE
  } else if(isVolFlow && !loggingError){  
    logAxis <- TRUE
  }
  
  return(logAxis)
}

############ used in uvhydrograph-render and vdiagram-render ############ 

#' @importFrom grDevices png
#' @importFrom grDevices dev.off
testCallouts <- function(plot_obj, xlimits){
  xrange <- diff(xlimits)
  buffer <- 0.04*xrange
  xlow <- xlimits[1]-buffer
  xhigh <- xlimits[2]+buffer
  xlimits_real <- c(xlow, xhigh)
  
  png('TMP_PLOT')
  print(plot_obj)
  width_char <- par("cxy")[1]
  #When you're done
  dev.off()
  #Delete the plot you just generated
  unlink('TMP_PLOT')
  
  i_view12 <- which(names(plot_obj$view.1.2) == "callouts")
  i_view14 <- which(names(plot_obj$view.1.4) == "callouts")
  
  testCalloutsByView <- function(plot_obj, callouts_index, view_num, xlimits_real, width_char, xrange){
    for(i in callouts_index){
        callout_args <- plot_obj[[view_num]][[i]]
        if (!is.na(xtfrm(callout_args$x[i])) |  
            !is.na(xtfrm(callout_args$y[i])) |
            is.null(xtfrm(callout_args$x[i])) |  
            is.null(xtfrm(callout_args$y[i]))) {  
          text_len <- nchar(callout_args$labels)
            
            len <- ifelse(is.null(callout_args$length), 0.1, callout_args$length)
            
            xend <- len * xrange * cos(2*pi*(30/360))
            xnew <- callout_args$x + xend + (width_char * text_len) 
            tooLong <- xnew > xlimits_real[2]
              
            if(any(tooLong)){
              out <- which(tooLong)
              notout <- which(!tooLong)
              plot_obj[[view_num]][[i]]$angle[notout] <- NA
              plot_obj[[view_num]][[i]]$angle[out] <- 150
            }
        }
    }
    return(plot_obj)
  }
  
  plot_obj <- testCalloutsByView(plot_obj, i_view12, 'view.1.2', xlimits_real, width_char, xrange)
  plot_obj <- testCalloutsByView(plot_obj, i_view14, 'view.1.4', xlimits_real, width_char, xrange)
  
  return(plot_obj)
}

############ used in uvhydrograph-render, dvhydrograph-render, fiveyeargwsum-render ############ 

rm.duplicate.legend.items <- function(object){
  
  which.duplicated <- which(duplicated(object$legend$legend.auto$legend))
  if(length(which.duplicated) > 0){
    object$legend$legend.auto <- lapply(object$legend$legend.auto, function(legend.arg, which.duplicated) {
        legend.arg[-which.duplicated]
    }, which.duplicated = which.duplicated)
  }

  return(object)
}

############ used in sitevisitpeak-data and sensorreading-data ############ 

formatComments <- function(comments){
  split_comments <- unlist(comments)
  if(is.null(split_comments) || nchar(split_comments) == 0){return(split_comments)}
  htmlbreaks_inside <- lapply(split_comments, gsub, pattern="\r\n", replacement="</br>")
  htmlbreaks_end <- lapply(htmlbreaks_inside, paste0, "</br>", collapse="")
  table_comments <- do.call(paste0, htmlbreaks_end)
  return(table_comments)
}

############ used in sensorreading-data and sitevisitpeak-data ############ 

isEmpty <- function(val){
  result <- (is.null(val) || is.na(val))
  return(result)
}

############ used in various places ############ 

#' Indicate whether a value is NULL, NA, or the empty string; or whether a named
#' object exists in a list of objects.
#' 
#' @param val A value.
#' @param listObjects A list of objects; can be empty.
#' @param objectName An object name.
#' @export
isEmptyOrBlank <- function(val = NULL, listObjects = NULL, objectName = NULL) {
  if(is.null(objectName)){
    result <- (length(val)==0 || isEmpty(val) || as.character(val)=="")
  } else {
    result <- !objectName %in% listObjects
  }
  return(result)
}

############ used in uvhydrograph-data, dvhydrograph-data, fiveyeargwsum-data ############ 

#' Determine whether a variable is (semantically) empty.
#' 
#' @param variable A variable's value.
#' @export
isEmptyVar <- function(variable) {
  result <- all(is.null(variable) || nrow(variable) == 0 || is.null(nrow(variable)), 
                is.null(variable) || length(variable$time[!is.na(variable$time)]) == 0)
  return(result)
}

isNullOrFalse <- function(variable) {
	return(is.null(variable) || 
      (!is.null(variable) && variable == FALSE))
}

#' If there are gaps in the time series, don't connect them. This creates
#' multiple line/point calls if there are gaps.
#' 
#' @param data The original list format of JSON.
#' @param ts Current time series data.
#' @param isDV Logic for whether this plot uses daily values or not.
splitDataGaps <- function(data, ts, isDV){
  
  data_list <- data[[ts$field[1]]]

  #Add zero/negative gaps
  zeroNegativeGaps <- findZeroNegativeGaps(ts$field[1], data, isDV)
  if("gaps"  %in% names(data_list)){
      data_list$gaps <- rbind(data_list$gaps, zeroNegativeGaps)
  } else {
      data_list$gaps <- zeroNegativeGaps
  }
  
  hasGaps <- "gaps"  %in% names(data_list) && !isEmptyOrBlank(data_list$gaps)
  hasEstimatedRangesAsGaps <- (isEmptyOrBlank(ts$estimated) || !ts$estimated) && 
    "estimatedPeriods"  %in% names(data_list) && 
    !isEmptyOrBlank(data_list$estimatedPeriods)
  isEstimated <- !isEmptyOrBlank(ts$estimated) && ts$estimated
  
  if(hasGaps || hasEstimatedRangesAsGaps || isEstimated){

    if(hasGaps) {
      startGaps <- flexibleTimeParse(data_list$gaps$startTime, timezone = data$reportMetadata$timezone)
      endGaps <- flexibleTimeParse(data_list$gaps$endTime, timezone = data$reportMetadata$timezone)
    } else {
      startGaps <- c()
      endGaps <- c()
    }
    
    if(hasEstimatedRangesAsGaps) {

      if(isDV){
        # remove any time value for dv estimated times (should be for a whole day)
        startEstimated <- unlist(as.POSIXct(strptime(data_list$estimatedPeriods$startDate, "%F")))
        endEstimated <-  unlist(as.POSIXct(strptime(data_list$estimatedPeriods$endDate, "%F")))
      } else {
        startEstimated <- data_list$estimatedPeriods$startDate
        endEstimated <- data_list$estimatedPeriods$endDate
      }
      
      startEstimated <- flexibleTimeParse(startEstimated, timezone = data$reportMetadata$timezone)
      endEstimated <- flexibleTimeParse(endEstimated, timezone = data$reportMetadata$timezone)
      
      startGaps <- c(startGaps, startEstimated)
      endGaps <- c(endGaps, endEstimated)
    }
    
    if(isEstimated){
            
      if(isDV){
        # remove any time value for dv estimated times (should be for a whole day)
        endEstimatedGaps <- unlist(as.POSIXct(strptime(data_list$estimatedPeriods$startDate, "%F")))
        startEstimatedGaps <- unlist(as.POSIXct(strptime(data_list$estimatedPeriods$endDate, "%F")))
      } else {
        endEstimatedGaps <- data_list$estimatedPeriods$startDate
        startEstimatedGaps <- data_list$estimatedPeriods$endDate
      }

      startEstimatedGaps <- c(as.POSIXct(strptime(data_list$startTime, "%F")), startEstimatedGaps)
      endEstimatedGaps <- c(as.POSIXct(strptime(data_list$endTime, "%F")), endEstimatedGaps)
      
      startEstimatedGaps <- flexibleTimeParse(startEstimatedGaps, timezone = data$reportMetadata$timezone)
      endEstimatedGaps <- flexibleTimeParse(endEstimatedGaps, timezone = data$reportMetadata$timezone)
      
      startGaps <- c(startGaps, startEstimatedGaps)
      endGaps <- c(endGaps, endEstimatedGaps)
    }
    
    #This is causing DV steps to be rendered at noon instead of on the day marks. 
    #Re-enable after refactor of time parsing functions?
    #if(isDV){ ts$time <- flexibleTimeParse(ts$time, timezone = data$reportMetadata$timezone) }
    
    startGaps <- sort(startGaps)
    endGaps <- sort(endGaps)

    # working with list data (fiveyr and dvhydro)
    if(class(ts) == "list"){
      dataWithoutGaps <- data.frame(time = ts$time, value = ts$value,
                                    stringsAsFactors = FALSE)
    } else if(class(ts) == "data.frame"){
      dataWithoutGaps <- ts
    } else {
      dataWithoutGaps <- data.frame()
    }
    
    dataSplit <- list()
    for(g in 1:length(startGaps)){
      
      if(isDV) {
        dataBeforeGap <- dataWithoutGaps[which(flexibleTimeParse(dataWithoutGaps[['time']], data$reportMetadata$timezone, TRUE) <= startGaps[g]),]
        dataWithoutGaps <- dataWithoutGaps[which(flexibleTimeParse(dataWithoutGaps[['time']], data$reportMetadata$timezone, TRUE) >= endGaps[g]),]
      } else {
        dataBeforeGap <- dataWithoutGaps[which(dataWithoutGaps[['time']] <= startGaps[g]),]
        dataWithoutGaps <- dataWithoutGaps[which(dataWithoutGaps[['time']] >= endGaps[g]),]
      }
      

      # only add dataBeforeGap if it exists, sometimes gap dates are earlier than any data 
      if(!isEmptyVar(dataBeforeGap)) { 
        dataSplit <- append(dataSplit, list(dataBeforeGap))
      }
      
      #leave the loop when there is no data left to split, sometimes gap dates are later than any
      if(isEmptyVar(dataWithoutGaps)) { 
        break  
      }
      
    }
    
    if(!isEmptyVar(dataWithoutGaps)){
      dataSplit <- append(dataSplit, list(dataWithoutGaps))
    }
    
    if(class(ts) == "list"){
      dataSplit <- lapply(dataSplit, function(d, legend.name){
        d <- as.list(d)
        d$legend.name <- legend.name
        return(d)
      }, legend.name = ts$legend.name)
    }
    
  } else {
    dataSplit <- list(ts)
  }

  return(dataSplit)
}

#' Use \code{splitDataGaps} and Format the Resulting Data Correctly
#' 
#' @param data The original list format of JSON.
#' @param relevantData All time-series/variables that are not empty (equals
#'        \code{allVars} in the \code{*-data.R} script).
#' @param isDV Logic for whether this plot uses daily values or not.
#' @export
applyDataGaps <- function(data, relevantData, isDV = FALSE) {

  #separate data with gaps
  haveField <- unlist(lapply(relevantData, function(v){"field" %in% names(v)}))
  gapData <- unlist(lapply(relevantData[haveField], splitDataGaps, data=data, isDV=isDV), recursive=FALSE)
  
  if(!isEmptyOrBlank(gapData)){
    pattern <- paste0("(", paste(names(relevantData), collapse="|"), ")")
    names(gapData) <- regmatches(names(gapData), m=regexpr(pattern, names(gapData)))
    #add data back together
    relevantDataWithGaps <- append(relevantData[!haveField], gapData)
  } else {
    relevantDataWithGaps <- relevantData
  }
  
  return(relevantDataWithGaps)
}

#' Put the SIMS URL (if it exists) Into the Base of the Report
#' 
#' @param data Coming in to create a plot which may have SIMS info.
#' @export
#' @rdname getSimsUrl
getSimsUrl<- function(data){
  url <- data$simsUrl
  if(is.null(url) || url == '') {
    url <- "SIMS URL: NA"
  } else {
    url <- paste("<a href='",url,"' target='_blank'>","SIMS URL:",url,"</a>")
  }
  return(url)
}

#' Put the waterdata.usgs.gov URL (if it exists) Into the Base of the Report
#' 
#' @param data Coming in to create a plot which may have waterdata info.
#' @export
#' @rdname getWaterDataUrl
getWaterDataUrl <- function(data) {
  url <- data$waterdataUrl
  if (is.null(url) || url == '') {
    url <- "waterdata.usgs.gov URL: NA"
  } else {
    url <- paste("<a href='",url,"' target='_blank'>","waterdata.usgs.gov URL:",url,"</a>")
  }
  return(url)
}

#' Apply Styles (and some properties) to Approval Bar Rectangles
#' 
#' @param object A gsplot, plot object.
#' @param data A list of gsplot objects to display on the plot.
#' @return A gsplot object with approval bar rectangle styles applied.
ApplyApprovalBarStyles <- function(object, data) {
  ylim <- ylim(object)$side.2
  ylog <- object$global$par$ylog

  if (ylim[1] == ylim[2]) {
    # Cope with the rare case of the time series plot being a horizontal line,
    # in which case we have to preemptively compensate for some y-axis interval
    # defaulting code inside R graphics. The 40% factor here comes from the R
    # source code, last seen at 
    # http://docs.rexamine.com/R-devel/Rgraphics_8h.html#a5233f80c52d4fd86d030297ffda1445e
    if (!isEmptyOrBlank(ylog) && ylog) {
      ylim <- c(10^(0.6 * log10(ylim[1])), 10^(1.4 * log10(ylim[2])))
    }
    else {
      ylim <- c(0.6 * ylim[1], 1.4 * ylim[2])
    }
  }
  # calculate approval bar rectangle, vertical extent
  ybottom <- ApprovalBarYBottom(ylim, ylog, object$side.2$reverse)
  ytop <- ApprovalBarYTop(ylim, ylog, object$side.2$reverse)
  
  # for any approval intervals present...
  for (i in grep("^appr_.+_uv$", names(data))) {
    # look up style
    approvalBarStyles <- getApprovalBarStyle(data[i], ybottom, ytop)
    for (j in names(approvalBarStyles)) {
      # apply the styles
      object <- do.call(names(approvalBarStyles[j]),
                        append(list(object = object), approvalBarStyles[[j]]))
    }
  }
  return(object)
}

#' Compute the Top Position of Approval Bars
#' 
#' @param lim The y-axis real interval, as two element vector.
#' @param ylog A Boolean truth value indicating whether the y-axis is log_10
#'        scale: TRUE => log_10; FALSE => linear.
#' @param reverse A Boolean truth value indicating whether the y-axis is
#'        inverted: TRUE => inverted y-axis; FALSE => not inverted.
#' @return The appropriate approval bar vertical top extent, in world
#'         coordinates.
ApprovalBarYTop <- function(lim, ylog, reverse) {
  return(ApprovalBarY(lim, ylog, reverse, 0.0245))
}

#' Compute the Bottom Position of Approval Bars
#' 
#' @param lim The y-axis real interval, as two element vector.
#' @param ylog A Boolean truth value indicating whether the y-axis is log_10
#'        scale: TRUE => log_10; FALSE => linear.
#' @param reverse A Boolean truth value, indicating whether the y-axis is
#'        inverted: TRUE => inverted y-axis; FALSE => not inverted.
#' @return The appropriate approval bar vertical bottom extent, in world
#'         coordinates.
ApprovalBarYBottom <- function(lim, ylog, reverse) {
  return(ApprovalBarY(lim, ylog, reverse, 0.04))
}

#' Compute the Top or Bottom Vertical Position of Approval Bars
#' 
#' @param lim The y-axis real interval, as two element vector.
#' @param ylog A Boolean truth value, indicating whether the y-axis is log_10 scale:
#'             TRUE => log_10; FALSE => linear.
#' @param reverse A Boolean truth value, indicating whether the y-axis is inverted:
#'                TRUE => inverted y-axis; FALSE => not inverted.
#' @param ratio A scaling ratio to adjust the top or bottom of approval bar
#'        rectangle.
#' @return The appropriate approval bar top or bottom y-axis coordinate, in
#'         world coordinates.
ApprovalBarY <- function(lim, ylog = NULL, reverse, ratio) {
  e.0 <- lim[1]
  e.1 <- lim[2]
  
  ylog <- ifelse(isEmptyOrBlank(ylog), FALSE, ylog)
  reverse <- ifelse(isEmptyOrBlank(reverse), FALSE, reverse)
  
  # if this is a log10 y-axis
  if (ylog) {
    y <- 10^(log10(e.0) - ratio * (log10(e.1) - log10(e.0)))
  }
  else {
      y <- e.0 - ratio * (e.1 - e.0)
  }
  
  return(y)
}

#' Rescale the Top of y-axis to Create an Approximately 4% Margin Between the
#' Vertical Top Extent of Plot Objects and the Top Edge of Plot
#' 
#' @description This function is an inaccurate emulation of (the top-end-of-plot
#'   behavior of) R \code{graphics::par}'s \code{yaxs = 'r'} state, because we have
#'   to use \code{yaxs = 'i'} in spots, but still want the ~4% margin at the top
#'   of the plot, so we adjust the y-axis endpoint accordingly after we do what
#'   we need.
#' 
#' @param object A gsplot, plot object.
#' @return The passed-in gsplot object, with the y-axis top augmented upwards
#'         appropriately.
RescaleYTop <- function(object) {
  ylog <- par("ylog")
  reverse <- object$side.2$reverse
  
  # Desired top margin, in NDCs. See also "yaxs" parameter domain in
  # graphics::par.
  m <- 0.04
  
  # vertical extent and length
  e <- ylim(object)$side.2
  e.length <- abs(e[1] - e[2])
  
  if (ylog) {
    # TODO: the log10 calculations below should probably be upgraded to mirror
    # the form of analogous formulae in the linear-case, conditionals in the
    # block below.
    
    # if the y-axis is inverted
    if (reverse) {
      object$side.2$lim[1] <- 10^((1 - m) * log10(e[2]))
    }
    else {
      object$side.2$lim[2] <- 10^((1 + m) * log10(e[2]))
    }
  }
  else {
    # if the y-axis is inverted
    if (reverse) {
      object$side.2$lim[1] <- e[2] - m * e.length
    }
    else {
      # The 5.14 coefficient below is a hack that was reverse-engineered from 
      # the SVG output (using Inkscape, and the "back-of-the-envelope"). At the 
      # moment, we have no idea why it works, and is likely not robust enough 
      # for production.
      object$side.2$lim[2] <- e[2] + 5.14 * m * e.length
    }
  }
  
  return(object)
}

#' Add x-axis Labels to Five Year GW Summary Plots, and DV Hydrographs,
#' Having Time Intervals of One Year or More
#' 
#' @param object A gsplot, plot object.
#' @param text A vector of month abbreviations.
#' @param at.months A vector of month dates to label month abbreviations (in
#'                  "text" vector) at.
#' @param at.years A vector of dates to label years at.
#' @return The passed-in gsplot object, with x-axis labeled.
XAxisLabels <- function(object, text, at.months, at.years) {
  return(
    mtext(
      object,
      text = text, at = at.months,
      cex = 0.5, side = 1
    ) %>%
      mtext(
        text = year(at.years), at = at.years,
        line = 1, side = 1
      )
  )
}

#' Delineate Year Boundaries on Five Year GW Summary Plots, and DV Hydrographs, 
#' Having Time Intervals of One Year or More
#' 
#' @param object A gsplot, plot object.
#' @param years A sequence of year-point-type begin dates to draw the lines at.
#' @return The passed-in gsplot object, with year boundaries delineated.
DelineateYearBoundaries <- function(object, years) {
  return(
    abline(
      object,
      v = years, col = "gray47",
      lwd = 2, where = 'first'
    )
  )
}

#Will clear out any folders and files in temp folder that are older than 5 minutes
cleanTempSpace <- function() {
  tempdir <- dirname(tempfile())
  allTempFiles <- paste0(tempdir, "/", list.files(tempdir))
  lastAccessTimes <- file.info(allTempFiles)$atime
  
  for (i in 1:length(allTempFiles)) { 
    if(difftime(Sys.time(), lastAccessTimes[i], units="mins") > 5) { #delete anything older than 5 minutes
      unlink(allTempFiles[i], recursive=TRUE)
    }
  }
}

#' Convert a String to the Equivalent HTML Code
#' 
#' @param characters The string to convert.
#' @return The equivalent HTML codes for the string.
convertStringToTableDisplay <- function(characters){
  characters <- gsub(">", "&gt;", gsub("<", "&lt;", characters))
  return(characters)
}

#' Convert a String From HTML Code to the Equivalent Raw Characters
#' 
#' @param characters The characters to convert.
#' @return The equivalent string for the HTML codes.
convertTableDisplayToString <- function(characters){
  characters <- gsub("&gt;", ">", gsub("&lt;", "<", characters))
  return(characters)
}