#' Parse DV Time Series
#'
#' @description A wrapper for the readTimeSeries functions that handles
#' errors thrown by those functions if the specified time series is
#' not found and throws a warning message. Also handles time series that
#' are returned without any point data and treats them as NULL.
#' @param reportObject the full report JSON object
#' @param seriesField the JSON field name for the TS data 
#' @param descriptionField the JSON field name for the TS legend name
#' @param timezone The timezone to parse the TS points into
#' @param excludeZeroNegativeFlag whether or not to exclude zero and negative values
#' @param estimated whether or not the retrieved time series should be estimated or non-estimated
#' @return The requested time series or NULL if the request time series was not found.
parseDVTimeSeries <- function(reportObject, seriesField, descriptionField, timezone, excludeZeroNegativeFlag, estimated=FALSE){
  timeSeries <- tryCatch({
    if(estimated){
      readEstimatedTimeSeries(reportObject, seriesField, timezone=timezone, descriptionField=descriptionField, isDV=TRUE)
    } else {
      readNonEstimatedTimeSeries(reportObject, seriesField, timezone=timezone, descriptionField=descriptionField, isDV=TRUE)
    }
  }, error=function(e) {
    warning(paste("Returning NULL for DV Hydro Time Series: {", seriesField, "}. Error:", e))
    return(NULL)
  })

  if(isEmptyOrBlank(timeSeries) || !anyDataExist(timeSeries[['points']])){
    return(NULL)
  }

  return(timeSeries)
}

#' Parse DV Approvals
#'
#' @description Given a time series, read and format the approvals
#' data from it into apprpoval bars to put on the plot.
#' @param timeSeries the time series to get approvals for
#' @param timezone the timezone to parse the approval times into
parseDVApprovals <- function(timeSeries, timezone){
  approvalBar <- readApprovalBar(timeSeries, timezone, legend_nm=timeSeries[['legend.name']], snapToDayBoundaries=TRUE)
  return(approvalBar)
}

#' Parse DV Field Visit Measurements
#'
#' @description Given the full report JSON object, reads the field
#' visit measurements and handles read errors.
#' @param reportObject the full report JSON object
parseDVFieldVisitMeasurements <- function(reportObject){
  meas_Q <- tryCatch({
    readFieldVisitMeasurementsQPoints(reportObject)
  }, error = function(e) {
    warning(paste("Returning NULL as DV Hydro field visit measurements. Error:", e))
    return(NULL)
  })

  if(!anyDataExist(meas_Q) || nrow(meas_Q) == 0){
    meas_Q <- NULL
    warning("Data was retrieved for field visit measurements but it was empty. Returning NULL.")
  }
  return(meas_Q)
}

#' Parse DV Ground Water Levels
#'
#' @description Given the full report JSON object reads the ground
#' water levels and handles read errors.
#' @param reportObject the full report JSON object
parseDVGroundWaterLevels <- function(reportObject){
  gw_level <- tryCatch({
    readGroundWaterLevels(reportObject)
  }, error = function(e) {
    warning(paste("Returning NULL as DV Hydro ground water levels. Error:", e))
    return(NULL)
  })

  if(!anyDataExist(gw_level) || nrow(gw_level) == 0){
    gw_level <- NULL
    warning("Data was retrieved for ground water levels but it was empty. Returning NULL.")
  }
  return(gw_level)
}

#' Parse DV Min Max IVs
#'
#' @description Given the full report JSON object, reads the
#' min and max IVs and formats them properly for plotting
#' @param reportObject the full report JSON object
#' @param timezone the time zone to parse points into
#' @param type the type of TS that these points belong to
#' @param invertedFlag whether or not the axis for the TS is inverted
#' @param excludeMinMaxFlag wheter or not min / max IVs should be plotted or labeled
#' @param excludeZeroNegativeFlag whether or not zero/negative values are included
#' @return a list containing the min and max IV values names as 'max_iv' and 'min_iv'
parseDVMinMaxIVs <- function(reportObject, timezone, type, invertedFlag, excludeMinMaxFlag, excludeZeroNegativeFlag){
  #Get max and min IV points
  max_iv <- getMinMaxIV(reportObject, "MAX", timezone, type, invertedFlag)
  min_iv <- getMinMaxIV(reportObject, "MIN", timezone, type, invertedFlag)
  returnList <- NULL

  #Make sure at least one value is valid
  if(!anyDataExist(max_iv) && !anyDataExist(min_iv)){
    return(NULL)
  }

  #If we are excluding min/max points or if we are excluding zero / negative
  #points and the max/min vlaues are zero / negative, then replace them
  #with labels that go on the top of the chart.

  #Max Checking
  if( (!isEmptyOrBlank(excludeMinMaxFlag) && excludeMinMaxFlag) || 
      (!isEmptyOrBlank(excludeZeroNegativeFlag) && excludeZeroNegativeFlag && !isEmptyOrBlank(max_iv[['value']]) && as.numeric(max_iv[['value']]) <= 0)){
    returnList <- list(max_iv_label=max_iv)
  }  else if(anyDataExist(max_iv[['value']])){
    returnList <- list(max_iv=max_iv)
  }

  #Min Checking
  if( (!isEmptyOrBlank(excludeMinMaxFlag) && excludeMinMaxFlag) 
      || (!isEmptyOrBlank(excludeZeroNegativeFlag) && excludeZeroNegativeFlag && !isEmptyOrBlank(min_iv[['value']]) && as.numeric(min_iv[['value']]) <= 0) ){
    returnList <- append(returnList, list(min_iv_label=min_iv))
  } else if(anyDataExist(min_iv[['value']])) {
    returnList <- append(returnList, list(min_iv=min_iv))
  }

  #Check if the IVs allow for a log axis or not
  returnList[['canLog']] <- TRUE
  
  if((!isEmptyOrBlank(returnList[['max_iv']][['value']]) && returnList[['max_iv']][['value']] <= 0) || (!isEmptyOrBlank(returnList[['min_iv']][['value']]) && returnList[['min_iv']][['value']] <= 0)){
    returnList[['canLog']] <- FALSE
  }

  return(returnList)
}

#' Create vertical step edges between estimated and non-estimated series
#' @description Given a stat TS and an estimated TS this function creates
#' vertical lines connecting the steps between those TS.
#' @param stat the parsed non-estimated time series
#' @param est the parsed estimated time series
#' @param excludeZeroNegativeFlag whether or not zero / negative values
#' will be removed
#' @return a list of vertical lines connecting steps between stat and est
#' @importFrom dplyr arrange
#' @return a list of the edges with the folowing columns time, y0, y1,
#' and newSet. Time is the x position of the edge, y0 is the first y
#' value and y1 is the second. newSet is what the next time series is
getEstimatedEdges <- function(stat, est, excludeZeroNegativeFlag=NULL){
  estEdges <- list()

  if(is.null(stat) || is.null(est) || isEmptyOrBlank(est[['points']][['value']]) || isEmptyOrBlank(stat[['points']][['value']])){
    return(NULL)
  }

  #Don't render edges for values that will be removed if we are exculding zero and negative values
  if(!is.null(excludeZeroNegativeFlag) && excludeZeroNegativeFlag){
    stat[['points']] <- removeZeroNegative(stat[['points']])
    est[['points']] <- removeZeroNegative(est[['points']])
  }

  est <- est[['points']][c('time', 'value')]
  stat <- stat[['points']][c('time', 'value')]

  . <- NULL # work around warnings from devtools::check()
  estData <- est %>% as.data.frame %>% mutate(set=rep('est', nrow(.)))
  statData <- stat %>% as.data.frame %>% mutate(set=rep('stat', nrow(.)))

  #Merge data into a single DF
  data <- rbind(estData, statData)
  
  # work around irrelevant warnings from devtools::check()
  time <- NULL
  y0 <- 0
  value <- 0
  set <- NULL
  
  estEdges <- data %>% arrange(time) %>%
          mutate(y0 = ifelse(set != lag(set), lag(value), NA)) %>%
          filter(set != lag(set)) %>% select(time, y0, y1 = value, newSet=set) %>% as.list

  return(estEdges)
}

#' Get the Min/Max IV Data
#'
#' @description Reads the Max/Min IV Data from the reportObject then takes the
#' first entry and formats it properly for use on the DV Hydrograph report.
#' @param reportObject the full report data
#' @param stat the stat to look up (MAX or MIN)
#' @param tsType the type of the TS (to use for the legend name)
#' @param timezone the timezone to parse the times into
#' @param inverted whether or not the TS is inverted
#' @return the first min or max IV data point from the list of min max IVs
getMinMaxIV <- function(reportObject, stat, timezone, tsType, inverted){
  IVData <- tryCatch({
    readMinMaxIVs(reportObject, stat, timezone, inverted)
  }, error=function(e) {
    warning(paste("Returning NULL for DV hydro ", stat, " IV value. Error:", e))
    return(NULL)
  })

  if(is.null(IVData) | isEmptyOrBlank(IVData)){
    returnList <- NULL
  } else {
    legend_nm <- paste(IVData[['label']], tsType, ":", IVData[['value']][1])
    returnList <- list(time=IVData[['time']][1], value=IVData[['value']][1], legend.name=legend_nm)
  }

  return(returnList)
}

#' Use the last point plus 1 day in seconds to extend step
#' the points do not have times, but the x limit is extended with a time to show the whole day
#' the step needs to be extended to meet this time
#' @param toPlot list of items that will be called in the do.call 
extendStep <- function(toPlot){
  #check first whether it's a feature added to the plot as a step
  isStep <- 'type' %in% names(toPlot) && toPlot[['type']] == "s"
  
  if(isStep){
    daySeconds <- 24 * 60 * 60 #1 day in seconds
    toPlot$x <- c(toPlot$x,  tail(toPlot$x, 1) + daySeconds)
    toPlot$y <- c(toPlot$y,  tail(toPlot$y,1))
    toPlot$legend.name <- c(toPlot$legend.name,  tail(toPlot$legend.name,1))
  }
  
  return(toPlot)
}

